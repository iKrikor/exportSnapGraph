\documentclass[prodmode,acmtecs]{acmsmall} % Aptara syntax

% Package to generate and customize Algorithm as per ACM style
\usepackage[ruled]{algorithm2e}
\usepackage{listings}
\usepackage{cite}
\renewcommand{\algorithmcfname}{ALGORITHM}
\SetAlFnt{\small}
\SetAlCapFnt{\small}
\SetAlCapNameFnt{\small}
\SetAlCapHSkip{0pt}
\IncMargin{-\parindent}

% Metadata Information
\acmVolume{1}
\acmNumber{1}
\acmArticle{0}
\acmYear{2015}
\acmMonth{10}


% DOI
%\doi{0000001.0000001}

%ISSN
%\issn{1234-56789}

% Document starts
\begin{document}

% Title portion
\title{Art\'{i}culo de investigaci\'{o}n: Exportar de Grafos}
\author{Krikor Bisdikian Gazarian
\affil{Tecnol\'{o}gico de Monterrey Campus Santa Fe}}

% NOTE! Affiliations placed here should be for the institution where the
%       BULK of the research was done. If the author has gone to a new
%       institution, before publication, the (above) affiliation should NOT be changed.
%       The authors 'current' address may be given in the "Author's addresses:" block (below).
%       So for example, Mr. Abdelzaher, the bulk of the research was done at UIUC, and he is
%       currently affiliated with NASA.

\begin{abstract}
En el siguiente art\'{i}culo de investigaci\'{o}n se comparar\'{a}n los diferentes m\'{e}todos para exportar un grafo y maneras de visualizarlo y realizar un an\'{a}lisis de los datos.
\end{abstract}


%
% The code below should be generated by the tool at
% http://dl.acm.org/ccs.cfm
% Please copy and paste the code instead of the example below. 
%
\begin{CCSXML}
<ccs2012>
<concept>
<concept_id>10003752.10003809.10003635</concept_id>
<concept_desc>Theory of computation~Graph algorithms analysis</concept_desc>
<concept_significance>300</concept_significance>
</concept>
</ccs2012>
\end{CCSXML}

\ccsdesc[300]{Theory of computation~Graph algorithms analysis}
%
% End generated code
%

\keywords{Grafo, exportar, importar}

\acmformat{Krikor Bisdikian Gazarian. 2015. Art\'{i}culo de investigaci\'{o}n: Exportar de Grafos.}
% At a minimum you need to supply the author names, year and a title.
% IMPORTANT:
% Full first names whenever they are known, surname last, followed by a period.
% In the case of two authors, 'and' is placed between them.
% In the case of three or more authors, the serial comma is used, that is, all author names
% except the last one but including the penultimate author's name are followed by a comma,
% and then 'and' is placed before the final author's name.
% If only first and middle initials are known, then each initial
% is followed by a period and they are separated by a space.
% The remaining information (journal title, volume, article number, date, etc.) is 'auto-generated'.

%\begin{bottomstuff}
%As\'{i} se ponen pies de p\'{a}gina.
%\end{bottomstuff}

\maketitle


\section{Introduction}
Los grafos son estructuras que nos permiten modelar relaciones entre muchos elementos. Hay diferentes tipos de grafos que permiten modelar relaciones m\'{a}s espec\'{i}ficas. Pueden ser dirigidos o no dirigidos, esto significa que la relaci\'{o}n entre los elementos tiene sentido. Y tambi\'{e}n pueden tener peso estas relaciones. 
% quote
%\begin{quote}
`%`As\'{i} se hace una cita".
%\end{quote}

%As\'{i} se enumera:
% itemize
%\begin{itemize}
%\item TCosa 1
%\item Cosa 2
%\item Cosa 3
%\end{itemize}

% Head 1
\section{Paso a paso}
Para importar los datasets y guardarlos en los diferentes formatos se busc\'{o} primero en la documentaci\'{o}n de SNAP como importar los datasets. Esto es relativamente f\'{a}cil ya que SNAP incluye una funci\'{o}n para hacerlo. 

Luego, se busc\'{o} en internet ejemplos de ls diferentes formatos. Y por \'{u}ltimo se hicieron funciones que recorrieran los v\'{e}rtices y las aristas del grafo, lo cual es relativamente f\'{a}cil ya que SNAP nos da iteradores y estas estructuras se guardan linealmente. Al recorrer las partes del grafo se iban guardando dependiendo del formato visto como ejemplo. Agregando antes el encabezado y los requerimientos necesarios.
% Head 2
%\subsection{Subsecci\'{o}n}

%As\'{i} se hace una ecuaci\'{o}n
% Numbered Equation
%\begin{equation}
%\label{eqn:01}
%P(t)=\frac{b^{\frac{t+1}{T+1}}-b^{\frac{t}{T+1}}}{b-1},
%\end{equation}

% description
%\begin{description}
%\item[RT Masters]
%$\mathcal{M}_{RT}=\{ \vec{m}_{1},\dots,\vec{m}_{n}\}$ 
%\end{description}

\section{Ventajas y Desventajas}
\subsection{GraphML}
Est\'{a} basado en XML lo cual lo hace f\'{a}cil de generar. Es de los m\'{a}s usados para almacenar gr\'{a}ficos. Lo malo es que no soporta tanta informaci\'{o}n.
\subsection{GEXF}
Es equivalente a GraphML ya que est\'{a} basado tambi\'{e}n en XML, aunque es menos utilizado que GraphML. 
\subsection{GDF}
Se utiliza para intercambiar datos en la industria de la navegaci\'{o}n automotriz. No est\'{a} hecho para ser utilizado a gran escala. Se debe convertir a un formato m\'{a}s eficiente para esto.
\subsection{JSON Graph Format}
No hay un est\'{a}ndar, cada librer\'{i}a genera su propio formato. Esto tambi\'{e}n es una ventaja ya que es m\'{a}s vers\'{a}til. 

% Figure
%\begin{figure}
%\centerline{\includegraphics{acmsmall-mouse}}
%\caption{Code before preprocessing.}
%\label{fig:one}
%\end{figure}

% Enunciations
\section{Complejidad Temporal y Espacial}
La complejidad temporal de los cuatro algoritmos es de O(V+E) ya que recorre todos los v\'{e}rtices y luego todas las aristas.
La complejidad espacial es constante.

\section{Tiempos de ejecuci\'{o}n}
\begin{itemize}
\item GraphML: 101
\item GEXF: 111
\item GDF: 63
\item JSON Graph Format: 93
\end{itemize}
% Table
%\begin{table}%
%\tbl{Tiempos de Ejecuci\'{o}n\label{tab:one}}{%
%\begin{tabular}{|l|l|}
%\hline
%Algoritmo   & Tiempo de Ejecuci\'{o}n (ms) \\\hline
%GraphML     & 101\\\hline
%GEXF &111\\\hline
%GDF     &63\\\hline
%JSON G. F.  &93\\\hline
%\end{tabular}}
%\end{table}


\section{Gephi}

\begin{figure}
\centerline{\includegraphics{grafo}}
\caption{Visualizaci\'{o}n grafo en Gephi}
\label{fig:one}
\end{figure}

Los grafos pueden llegar a ser estructuras muy complejas como para imaginarlas sin tenerlas visualmente. Cuando modelan muchas interacciones entre muchos v\'{e}rtices, como lo son los grafos de redes sociales. Es muy dif\'{i}cil analizarlo sin visualizarla, y dibujarla no tendr\'{i}a sentido. Gephi nos proporciona una herramienta en la que podemos interactuar con nuestros grafos de manera gr\'{a}fica. Aparte nos permite hacer varios an\'{a}lisis sobre el grafo. Uno de ellos, por ejemplo, es la distribuci\'{o}n de grado del grafo. Esto no es nada m\'{a}s que cuantas relaciones hay en promedio entre los nodos, es algo tan sencillo como apretar un bot\'{o}n para obtenerse. 

En el dataset utilizado que modela las relaciones en Facebook tenemos que la media de la distribuci\'{o}n de grado es de 21.843, es decir, en promedio el usuario en esta muestra muy peque\~{n}a tiene 22 "amigos".



                             
                             
% Electronic Appendix
\elecappendix

\medskip

\section{Funci\'{o}n a GraphML}
\begin{lstlisting}
void exportGraphML(PNGraph g) {
    std::ofstream file ("./facebook_combined.graphml");
    if (file.is_open())
    {
        file << "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n";
        file << "<graphml xmlns=\"http://graphml.graphdrawing.org/xmlns\" 
        xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" 
        xsi:schemaLocation=\"http://graphml.graphdrawing.org/xmlns 
        http://graphml.graphdrawing.org/xmlns/1.0/graphml.xsd\">\n";
        file << "<graph id=\"G\" edgedefault=\"directed\">\n";
        for (PNGraph::TObj::TNodeI NI = g->BegNI(); NI < g->EndNI(); NI++)
        {
            file << "<node id=\"" << NI.GetId() << "\"/>\n";
        }
        int i = 1;
        for (PNGraph::TObj::TEdgeI EI = g->BegEI(); EI < g->EndEI(); EI++, ++i)
        {
            file << "<edge id=\"e" << i << "\" source=\"" << EI.GetSrcNId() 
            << "\" target=\"" << EI.GetDstNId() << "\"/>\n";
        }
        
        file << "</graph>\n";
        file << "</graphml>\n";
        file.close();
    }
}
\end{lstlisting}

\section{Funci\'{o}n a GEXF}
\begin{lstlisting}
void exportGEXF(PNGraph g)
{
    std::ofstream file ("./facebook_combined.gexf");
    if (file.is_open())
    {
        file << "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n";
        file << "<gexf xmlns=\"http://www.gexf.net/1.2draft\" version=\"1.2\">\n";
        file << "<graph mode=\"static\" defaultedgetype=\"directed\">\n";
        file << "<nodes>\n";
        for (PNGraph::TObj::TNodeI NI = g->BegNI(); NI < g->EndNI(); NI++)
        {
            file << "<node id=\"" << NI.GetId() << "\" />\n";
        }
        file << "</nodes>\n";
        file << "<edges>\n";
        int i = 1;
        for (PNGraph::TObj::TEdgeI EI = g->BegEI(); EI < g->EndEI(); EI++, ++i)
        {
            file << "<edge id=\"" << i << "\" source=\"" << EI.GetSrcNId() 
            << "\" target=\"" << EI.GetDstNId() << "\" />\n";
        }
        file << "</edges>\n";
        file << "</graph>\n";
        file << "</gexf>\n";
        file.close();
    }
}

\end{lstlisting}

\section{Funci\'{o}n a GDF}
\nocite{*}
\begin{lstlisting}
void exportGDF(PNGraph g)
{
    std::ofstream file ("./facebook_combined.gdf");
    if (file.is_open())
    {
        file << "nodedef> name VARCHAR\n";
        for (PNGraph::TObj::TNodeI NI = g->BegNI(); NI < g->EndNI(); NI++)
        {
            file << NI.GetId() << "\n";
        }
        file << "edgedef>source VARCHAR, destination VARCHAR\n";
        for (PNGraph::TObj::TEdgeI EI = g->BegEI(); EI < g->EndEI(); EI++)
        {
            file << EI.GetSrcNId() << ", " << EI.GetDstNId() << "\n";
        }
        file.close();
    }
}
\end{lstlisting}

\section{Funci\'{o}n a JSON Graph Format}
\begin{lstlisting}
void exportJSON(PNGraph g)
{
    std::ofstream file ("./facebook_combined.json");
    if (file.is_open())
    {
        file << "{ \"graph\": {\n";
        file << "\"nodes\": [\n";
        for (PNGraph::TObj::TNodeI NI = g->BegNI(); NI < g->EndNI(); )
        {
            file << "{ \"id\": \"" << NI.GetId() << "\" }";
            if (NI++ == g->EndNI())
            {
                file << " ],\n";
            }
            else
            {
                file << ",\n";
            }
            
        }
        file << "\"edges\": [\n";
        for (PNGraph::TObj::TEdgeI EI = g->BegEI(); EI < g->EndEI(); )
        {
            file << "{ \"source\": \"" << EI.GetSrcNId() << "\", \"target\": \"" 
            << EI.GetDstNId() << "\" }";
            if (EI++ == g->EndEI())
            {
                file << " ]\n";
            }
            else
            {
                file << ",\n";
            }
        }
        file << "} }";
        file.close();
    }
}

\end{lstlisting}

\section{Github}
https://github.com/iKrikor/exportSnapGraph 

%\nocite{*}
%\bibliographystyle{acm}
%\bibliography{citatarea}

\begin{thebibliography}{9}

\bibitem{1}
  Social circles: Facebook: 2012. https://snap.stanford.edu/data/egonets-Facebook.html. Accessed: 2015-10-27.
  \bibitem{2}
  GraphML Primer: http://graphml.graphdrawing.org/primer/graphml-primer.html. Accessed: 2015-10-27.
    \bibitem{3}
  GEXF File Format: 2009. http://gexf.net/format/. Accessed: 2015-10-27.
      \bibitem{6}
 GDF Format: 2008-2015. http://gephi.github.io/users/supported-graph-formats/gdf-format/. Accessed: 2015-10-27.
      \bibitem{4}
  ACM LaTeX Style Guide: 2015. http://www.acm.org/publications/article-templates/acm-latex-style-guide. Accessed: 2015-10-27.
      \bibitem{5}
  GraphSON Reader and Writer Library: 2013. https://github.com/tinkerpop/blueprints/wiki/GraphSON-Reader-and-Writer-Library. Accessed: 2015-10-27.
\end{thebibliography}


                             % Sample .bib file with references that match those in
                             % the 'Specifications Document (V1.5)' as well containing
                             % 'legacy' bibs and bibs with 'alternate codings'.
                             % Gerry Murray - March 2012
\end{document}


